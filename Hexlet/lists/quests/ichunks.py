# В испытании "Чанкование" вам нужно было реализовать функцию, которая "нарезает" входную последовательность
# (любой iterable) на куски заданной длины. В этом же испытании вам нужно будет проделать нечто подобное,
# но уже с итератором — потенциально бесконечным! Иначе говоря, вам предстоит обрабатывать поток данных.
# Примерами таких потоков могут быть читаемый с диска файл очень большого размера или данные видео-трансляции,
# передаваемые по сети. В обоих случаях вы не можете себе позволить получить все данные сразу в виде структуры
# в памяти — вам её просто не хватит. И поэтому же вы не можете накапливать список кусочков внутри вашей функции,
# вам нужно возвращать поток кусочков.
#
# src/solution.py
# Реализуйте функцию ichunks, которая должна принимать в качестве аргументов размер кусочка (положительное целое число)
# и источник данных (итератор). Вернуть функция должна итератор списков заданной длины, содержащих элементы из источника
# данных.
#
# Внимание, в этот раз вам нужно будет формировать куски строго заданной длины! Если для последнего куска
# (если поток вообще закончится) не хватит элементов, то весь кусок отбрасывается!
#
# Примеры применения функции:
#
# >>> list(ichunks(2, [1, 2, 3, 4, 5]))
# [[1, 2], [3, 4]]
# >>> # ^ пятёрка была отброшена
# >>>
# >>> import itertools
# >>> # itertools.count() - бесконечный поток чисел 1, 2, 3...
# >>> list(itertools.islice(itertools.count(), 10000, 10005))
# [10000, 10001, 10002, 10003, 10004]
# >>>
# >>> stream = ichunks(3, itertools.count())  # поток троек чисел
# >>> list(itertools.islice(stream, 10000, 10002))
# [[30000, 30001, 30002], [30003, 30004, 30005]]
# Возможно, вы отметили, что имя функции начинается с "i" и отрезает то, что будет содержать возвращаемый итератор.
# Такое имя выбрано неспроста: похожим образом нередко именуют функции, работающие с итераторами.
# Например, несколько функций из стандартного модуля itertools названы в этом стиле.
#
# Замечания
# У нас, увы, нет возможности проверить код на переполнение памяти. Поэтому мы полагаемся на вашу ответственность.
# Если вы вернёте что-то вроде iter(huge_list), тесты будут пройдены,
# но такое решение не будет по-настоящему правильным!
#
# Подсказки
# Чтобы вернуть итератор, воспользуйтесь при решении функциями, которые уже возвращают итераторы:
# map, zip, функции из модуля itertools.
from itertools import count, islice
import itertools


# # BEGIN
# def ichunks(size, source):
#     return map(list, zip(*([iter(source)] * size)))
#     # "iter(source)" получает именно итератор, даже если на вход
#     # был передан iterable (строка, список).
#     #
#     # "[iterator] * n" размножает ссылки на итератор.
#     #
#     # "zip(*l)" пакует в кортежи все первые элементы из
#     # списка источников "l", затем все вторые, и так далее.
#     # Так как все источники для zip, это ссылки на один и тот же
#     # итератор, при переходе от ссылки к ссылке курсор передвигается
#     # всё дальше. Поэтому кортежи содержат последовательные элементы.
# # END

# def ichunks(size, iterable):
#     def func(elem1, elem2):
#         return elem2
#
#     cursor = iter(iterable)
#     while True:
#         res = list(map(func, range(size), cursor))
#         if len(res) < size:
#             break
#         yield res


def ichunks(size, iterable):
    cursor = iter(iterable)
    while True:
        res = list(map(lambda x, y: y, range(size), cursor))
        if len(res) < size:
            break
        yield res


def test_ichunks_with_lists():
    assert list(ichunks(1, [])) == []
    assert list(ichunks(2, [42])) == []
    assert list(ichunks(1, [100, 200])) == [[100], [200]]  # noqa: WPS221

    assert list(
        ichunks(3, ['a', 'b', 'c', 'd']),
    ) == [['a', 'b', 'c']]  # noqa: WPS221


def test_ichunks_with_iterator():
    # поток чисел "1000, 1003, 1006..."
    stream = count(1000, 3)

    assert list(
        islice(ichunks(1, stream), 3),
    ) == [[1000], [1003], [1006]]  # noqa: WPS221

    assert list(
        islice(ichunks(3, stream), 1),
    ) == [[1009, 1012, 1015]]  # noqa: WPS221


test_ichunks_with_lists()
test_ichunks_with_iterator()
