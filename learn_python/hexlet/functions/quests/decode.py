# Принцип кодирования
# При передаче логического нуля на вход кодирующего устройства
# передается потенциал, установленный на предыдущем такте
# (то есть состояние потенциала не меняется), а при передаче логической
# единицы потенциал инвертируется на противоположный.

# Реализуйте функцию decode, которая принимает cтроку в виде графического
# представления линейного сигнала и возвращает строку с бинарным кодом.
#
# Примеры использования:
# >>> decode('_|¯|____|¯|__|¯¯¯')
# '011000110100'
# >>> decode('|¯|___|¯¯¯¯¯|___|¯|_|¯')
# '110010000100111'
# >>> decode('¯|___|¯¯¯¯¯|___|¯|_|¯')
# '010010000100111'
# Подсказки
# Символ | в строке указывает на переключение сигнала и означает,
# что уровень сигнала в следующем такте, будет изменён на
# противоположный по сравнению с предыдущим.
# Если вам нужно будет склеить список строк в одну,
# воспользуйтесь конструкцией ''.join(list_of_strings)


# def decode(signal):
#     levels = ''.join(filter(lambda x: x != '|', signal))
#     # ^ удаляются "фронты" сигнала
#     # кстати, можно было сделать signal.replace('|', '')
#     start = signal[:1]
#     # ^ угадывается уровень "в недавнем прошлом"
#     return ''.join(map(
#         lambda p, c: '0' if p == c else '1',
#         start + levels,
#         levels,
#     ))
#     # ^ здесь сигнал без "фронтов" сравнивается с самим собой после сдвига
#     # '__¯____¯__¯¯¯'
#     # '_¯____¯__¯¯¯'
#     # и если сигнал изменился, то на выходе будет "1", иначе - "0"


def decode(code):
    result = []
    i = 0
    while i < len(code):
        if code[i] == "|":
            result.append("1")
            i += 2
            continue
        result.append("0")
        i += 1
    return ''.join(result)


def test_decode():
    assert decode('') == ''
    assert decode('|¯') == '1'
    assert decode('_') == '0'
    assert decode('_|¯|____|¯|__|¯¯¯') == '011000110100'
    assert decode('|¯|___|¯¯¯¯¯|___|¯|_|¯') == '110010000100111'
    assert decode('¯|___|¯¯¯¯¯|___|¯|_|¯') == '010010000100111'


test_decode()
